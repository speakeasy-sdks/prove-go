// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package prove

import (
	"bytes"
	"context"
	"fmt"
	"github.com/speakeasy-sdks/prove-go/pkg/models/operations"
	"github.com/speakeasy-sdks/prove-go/pkg/models/shared"
	"github.com/speakeasy-sdks/prove-go/pkg/utils"
	"io"
	"net/http"
	"strings"
)

// preFill - Operations or actions related to identity
type preFill struct {
	sdkConfiguration sdkConfiguration
}

func newPreFill(sdkConfig sdkConfiguration) *preFill {
	return &preFill{
		sdkConfiguration: sdkConfig,
	}
}

// GetIdentity - Get the Identity Information
// This endpoint request sends the phone number previously checked in the Eligibility API, along with either the SSN (full or last four digits) or date of birth, to then return the correct identity information for the consumer to autofill the customer's form/application.
func (s *preFill) GetIdentity(ctx context.Context, request shared.IdentityRequest) (*operations.GetIdentityResponse, error) {
	baseURL := utils.ReplaceParameters(s.sdkConfiguration.GetServerDetails())
	url := strings.TrimSuffix(baseURL, "/") + "/identity/v2"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s %s", s.sdkConfiguration.Language, s.sdkConfiguration.SDKVersion, s.sdkConfiguration.GenVersion, s.sdkConfiguration.OpenAPIDocVersion))

	req.Header.Set("Content-Type", reqContentType)

	client := s.sdkConfiguration.SecurityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetIdentityResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.IdentityResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.IdentityResponse = out
		}
	}

	return res, nil
}
